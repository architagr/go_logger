package logger

import (
	"fmt"
	"io"
	"sync"
)

// These flags define which text to prefix to each log entry generated by the Logger.
// Bits are or'ed together to control what's printed.
// With the exception of the Lmsgprefix flag, there is no
// control over the order they appear (the order listed here)
// or the format they present (as described in the comments).
// The prefix is followed by a colon only when Llongfile or Lshortfile
// is specified.
// For example, flags Ldate | Ltime (or LstdFlags) produce,
//	2009/01/23 01:23:23 message
// while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
//	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
const (
	Ldate         = "%lda" // the date in the local time zone: 2009/01/23
	Ltime         = "%lti" // the time in the local time zone: 01:23:23
	Lmicroseconds = "%lms" // microsecond resolution: 01:23:23.123123.  assumes Ltime.
	Llongfile     = "%llf" // full file name and line number: /a/b/c/d.go:23
	Lshortfile    = "%lsf" // final file name element and line number: d.go:23. overrides Llongfile
	Lutc          = "%utc" // if Ldate or Ltime is set, use UTC rather than the local time zone
	Lmsg          = "%lmg" // if Ldate or Ltime is set, use UTC rather than the local time zone
)

type Logger struct {
	mu     sync.Mutex
	wr     io.Writer
	format string
}

func NewLogger(writer io.Writer, format string) (*Logger, error) {
	_, err := validateFormat(format)
	if err != nil {
		return nil, err
	}
	return &Logger{wr: writer, format: format}, nil
}

func validateFormat(format string) ([]string, error) {
	var replacers []string = make([]string, 0)

	for i, length, count := 0, len(format), 0; i < length; {
		index, err := findNextReplaceIndex(i, format)
		if err != nil && count == 0 {
			return nil, fmt.Errorf("invalid format, no replacer found")
		}
		i = index + 4
		str := format[index : index+4]
		switch str{
		case Lmsg, Lutc, Ldate, Llongfile, Lmicroseconds, Lshortfile, Ltime:
			count++
			replacers = append(replacers, str)
		default:
			return nil, fmt.Errorf("invalid replacer %s", str)
		}
	}

	if len(replacers) == 0{
		return nil, fmt.Errorf("formater is empty")
	}else{
		return replacers, nil
	}
}

func findNextReplaceIndex(start int, format string) (int, error) {
	length := len(format)
	i := start
	for i < length {
		if format[i] != '%' {
			i++
		} else {
			break
		}
	}
	if i == length {
		return 0, fmt.Errorf("no new replacer found")
	}
	return i, nil
}
