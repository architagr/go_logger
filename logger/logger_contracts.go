package logger

import (
	"fmt"
	"io"
	"runtime"
	"strconv"
	"sync"
	"time"
)

// These flags define which text to prefix to each log entry generated by the Logger.
// Bits are or'ed together to control what's printed.
// With the exception of the Lmsgprefix flag, there is no
// control over the order they appear (the order listed here)
// or the format they present (as described in the comments).
// The prefix is followed by a colon only when Llongfile or Lshortfile
// is specified.
// For example, flags Ldate | Ltime (or LstdFlags) produce,
//	2009/01/23 01:23:23 message
// while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
//	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
const (
	Ldate         = "%lda" // the date in the local time zone: 2009/01/23
	Ltime         = "%lti" // the time in the local time zone: 01:23:23
	Lmicroseconds = "%lms" // microsecond resolution: 01:23:23.123123.  assumes Ltime.
	Llongfile     = "%llf" // full file name and line number: /a/b/c/d.go:23
	Lshortfile    = "%lsf" // final file name element and line number: d.go:23. overrides Llongfile
	Lmsg          = "%lmg" // if Ldate or Ltime is set, use UTC rather than the local time zone
	LType         = "%lty" // log category Debug, Info, error, fatal
)

type ILogger interface {
	Debug(message string)
	Info(message string)
	Error(message string)
	Fatal(message string)
}
type Logger struct {
	mu         sync.Mutex
	wr         io.Writer
	format     string
	utcTime    bool
	stackDepth int
	f          []string
}

func NewLogger(writer io.Writer, format string, utcTime bool, stackDepth int) (*Logger, error) {
	replacerStrings, err := validateFormat(format)
	if err != nil {
		return nil, err
	}
	return &Logger{
		wr:         writer,
		format:     format,
		f:          replacerStrings,
		utcTime:    utcTime,
		stackDepth: stackDepth,
	}, nil
}

func validateFormat(format string) ([]string, error) {
	var replacers []string = make([]string, 0)
	replacerStrings := make([]string, 0)
	for i, length, count := 0, len(format), 0; i < length; {
		index, nonReplacerString, err := findNextReplaceIndex(i, format)
		if err != nil && count == 0 {
			return nil, fmt.Errorf("invalid format, no replacer found")
		}
		i = index + 4
		str := format[index : index+4]
		switch str {
		case Lmsg, Ldate, Llongfile, Lmicroseconds, Lshortfile, Ltime, LType:
			count++
			replacerStrings = append(replacerStrings, nonReplacerString, str)
			replacers = append(replacers, str)
		default:
			return nil, fmt.Errorf("invalid replacer %s", str)
		}
	}

	if len(replacers) == 0 {
		return nil, fmt.Errorf("formater is empty")
	} else {
		return replacerStrings, nil
	}
}

func findNextReplaceIndex(start int, format string) (int, string, error) {
	length := len(format)
	var nonReplacerString []byte = make([]byte, 0)

	i := start
	for i < length {
		if format[i] != '%' {
			nonReplacerString = append(nonReplacerString, format[i])
			i++
		} else {
			break
		}
	}
	if i == length {
		return 0, "", fmt.Errorf("no new replacer found")
	}
	return i, string(nonReplacerString), nil
}

func getDate(t time.Time) string {
	output := make([]byte, 0)
	year, month, day := t.Date()
	output = append(output, strconv.Itoa(year)...)
	output = append(output, '-')
	output = append(output, month.String()...)
	output = append(output, '-')
	output = append(output, strconv.Itoa(day)...)

	return string(output)
}

func getTime(t time.Time) string {
	output := make([]byte, 0)
	hour, min, sec := t.Clock()
	output = append(output, strconv.Itoa(hour)...)
	output = append(output, ':')
	output = append(output, strconv.Itoa(min)...)
	output = append(output, ':')
	output = append(output, strconv.Itoa(sec)...)

	return string(output)
}

func getMicrosecond(t time.Time) string {
	return "."+strconv.Itoa(t.Nanosecond() / 1e3)
}

func getShortFile(file string, line int) string {
	output := make([]byte, 0)
	for i := len(file) - 1; i > 0; i-- {
		if file[i] == '/' {
			output = append(output, file[i+1:]...)
			break
		}
	}
	output = append(output, ':')
	output = append(output, []byte(strconv.Itoa(line))...)
	return string(output)
}

func getLongFile(file string, line int) string{
	output := make([]byte, 0)
	output = append(output, file...)
	output = append(output, ':')
	output = append(output, strconv.Itoa(line)...)
	return string(output)
}

func (l *Logger) formatMessage(message, file, logCategory string, line int, t time.Time) string {
	output := make([]byte, 0)
	if l.utcTime {
		t = t.UTC()
	}
	for _, str := range l.f {
		switch str {
		case Lmsg:
			output = append(output, message...)
		case Ldate:
			output = append(output, getDate(t)...)
		case Ltime:
			output = append(output, getTime(t)...)
		case Lmicroseconds:
			output = append(output, getMicrosecond(t)...)
		case Llongfile:
			output = append(output, getLongFile(file, line)...)
		case Lshortfile:
			output = append(output, getShortFile(file, line)...)
		case LType:
			output = append(output, logCategory...)
		default:
			output = append(output, str...)
		}
	}

	return string(output) + "\n"
}

func (l *Logger) Debug(message string) {
	l.mu.Lock()
	defer l.mu.Unlock()
	_, file, line, ok := runtime.Caller(l.stackDepth)
	if !ok {
		file = "???"
		line = 0
	}
	finalMessage := l.formatMessage(message, file, "Debug", line, time.Now())

	l.wr.Write([]byte(finalMessage))
}
func (l *Logger) Info(message string) {
	l.mu.Lock()
	defer l.mu.Unlock()
	_, file, line, ok := runtime.Caller(l.stackDepth)
	if !ok {
		file = "???"
		line = 0
	}
	finalMessage := l.formatMessage(message, file, "Info", line, time.Now())

	l.wr.Write([]byte(finalMessage))
}
func (l *Logger) Error(message string) {
	l.mu.Lock()
	defer l.mu.Unlock()
	_, file, line, ok := runtime.Caller(l.stackDepth)
	if !ok {
		file = "???"
		line = 0
	}
	finalMessage := l.formatMessage(message, file, "Error", line, time.Now())

	l.wr.Write([]byte(finalMessage))
}
func (l *Logger) Fatal(message string) {
	l.mu.Lock()
	defer l.mu.Unlock()
	_, file, line, ok := runtime.Caller(l.stackDepth)
	if !ok {
		file = "???"
		line = 0
	}
	finalMessage := l.formatMessage(message, file, "Fatal", line, time.Now())

	l.wr.Write([]byte(finalMessage))
}
